pidfile /var/run/redis/myapp.redice.root.1.7101.pid
daemonize yes

port 7101
bind 127.0.0.1

# сколько медленных открытых соединений может висеть в памяти (не отбрасываться)
# для высоко-нагруженных серверов стоит увеличить в соответствии с настройкой ядра
# tcp_max_syn_backlog
tcp-backlog 32

# закрывать соединения если клиент простаивает в течении N секунд (0 не закрывать никогда)
timeout 0

# отправлять TCP ACK для более точной проверки что сеть до клиента работает
# обычный опрос может проходить в то время как на промежуточных сетевых узлах может быть проблема
# каждые N сек, рекомендуемое значение 60 (0 - не проверять)
tcp-keepalive 0

# debug, verbose, notice, warning
loglevel notice

logfile /var/log/redis/myapp.redice.root.1.7101.log

# Используем 3 варианта DB (0 - production, 1 - development, 2 - test)
databases 1

# Правила сбрасывания данных на диск,
# чтобы отключить использование диска нужно закоментировать все save
# при количестве Redis серверов >=3 лучше отключить на мастерах
# save 900 1
# save 300 100
# save 60 10000

# перестать принимать запросы на запись если не возможно сбросить данные на диск
# работает если включено сбрасывание данных на диск
# stop-writes-on-bgsave-error yes

# сжимать строковые данные при сохранении дампа БД
rdbcompression yes

# добавлять данные для восстановления поврежденных файлов к дампам
# (-10% производительности при создании дампа)
rdbchecksum no

# рабочий каталог
dir /var/lib/redis/myapp

# файл дампа
dbfilename myapp.redice.root.1.7101.dump.rdb


# slaveof <masterip> <masterport>
slaveof 10.0.0.8 7181


# для slave. Будет отвечать если master отвалится (по умолчанию yes)
slave-serve-stale-data yes

# репликация на базе сокетов, на медленных дисках с быстрыми сетями работает быстрее
# по умолчанию отлючено (используется репликация через диск)
repl-diskless-sync yes

# Для бездисковой репликации, задержка в секундах
# сколько ждать подключения slave экземпляров для репликации
# в данном случае ждать 15 секунд, затем начинать репликацию
# кто не успел попадают в следующие сессии репликаций
repl-diskless-sync-delay 5

# как часто slave пингует Master (сек)
repl-ping-slave-period 3

# главный таймаут для пингов на репликацию
# должен быть больше чем repl-diskless-sync-delay
repl-timeout 10

# если Yes - отключить TCP_NODELAY пакеты
# сокращает расход трафика (отлично ускоряет работу при высоких нагрузках)
# увеличивает задержку появления данных на slave c master (~40ms)
repl-disable-tcp-nodelay yes

# размер буфера для запаси изменений, если slave на некоторое время отвалился
# новые данные (если не привысят размер буфера) будут залиты на slave
# или произойдет полная репликация
repl-backlog-size 1mb

# срок жизни буфера repl-backlog-size
# если slave отвалится на большее количество секунд
# при подключении произойдет полная репликация
repl-backlog-ttl 900

# Приоритет выбора в master (настройка для slave) от 0 до 100
# настройку использует Sentinel при выборе master (при отказе текущего)
# 100 - самый низкий, 1 - самый высокий, 0 - ни когда не выбирать как master
slave-priority 0

# минимально необходимое для работы мастера количество рабочих slave
min-slaves-to-write 1

# максимальный таймаут для записи в slave в секундах
# после чего master считается не рабочим и перестает принимать запросы
min-slaves-max-lag 3

################################### LIMITS ####################################

# Максимальное число одновременных подключений
# Default 10000 (в том числе 32 зарезервировано для внутренних нужд Redis)
maxclients 64

# Максимальное количество выделенной памяти для экземпляра
# С учетом буфера репликации (не должно быть как минимум меньше)
# При нехватке памяти Redis выселяет старые ключи при добавлении данных
maxmemory 5mb

# Политика освобождения памяти (удаления ключей) когда память заполняется
# volatile-lru -> удалить ключ с истечением срока, используя алгоритм LRU
# allkeys-lru -> удалить любой ключ в соответствии с алгоритмом LRU
# volatile-random -> удалить случайный ключ с заданным сроком действия
# allkeys-random -> удалить случайный ключ, любой ключ
# volatile-tll -> удалить ключ с ближайшим временем истечения срока (незначительный TTL)
# noeviction -> не истекает вообще, просто возвращает ошибку при операциях записи (default)
maxmemory-policy noeviction

# алгоритм определния кандидатов на выселение 1 - неточный но быстрый
# 10 - точный но медленнее (5 идеальное сочетание точность/скорость)
# не точный алгоритм выбора кандидатов по TTL
maxmemory-samples 1

# Максимально допустимое время выполнение скрипта LUA (мс)
# если превышено то выполнение останавливается с ошибкой
# значения 0 или -1 отключают опцию
lua-time-limit 3000

# Журнал медленных запросов (микросекунды)
# 1000000 - 1 секунда (-1 или 0 - отключить лог)
slowlog-log-slower-than 3000

# максимальная длинна записи в лог (нет предела)
slowlog-max-len 128

# Период среза статистики для самодиагностики (мс)
# 0 - отключить
latency-monitor-threshold 0

############################### ADVANCED CONFIG ###############################

# включить перекеширование на 1 мс на каждые 100 мс
# может замедлять время от времни  запросы до 20мс
# более эффективное использование памяти в реальном времни
# при настройке No - перекеширование происходит каждые 10 сек
# значительно ускоряет работу экземпляра
activerehashing no

# частота выполнения Redis-ом своих внутренних служб
# значение от 1 до 500
# чем выше значение тем отзывчевее Redis (например TTL точнее) но меньше времени
# тратится на обслуживание запросов клиентов (медленне работа команд/запросов)
# значение больше 10 практически не требуется (в редких случаях можно поднимть до 100)
# или совсем для экзотических до 500
hz 1
